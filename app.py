import os
import uuid
import openai
from flask import Flask, request, jsonify, send_file, render_template
from flask_cors import CORS
from config import SQLALCHEMY_DATABASE_URI, OPENAI_API_KEY
from db import db
from models import Project, Annotation, Report, Discussion
from utils import project_folder, save_upload, save_json

# Set OpenAI API Key
openai.api_key = OPENAI_API_KEY


def create_app():
    app = Flask(__name__, static_folder="static", template_folder="templates")
    app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    db.init_app(app)
    CORS(app, supports_credentials=True)

    with app.app_context():
        db.create_all()

    # ----------------------
    # FRONTEND ROUTE
    # ----------------------
    @app.route("/")
    def home():
        return render_template("index.html")  # load frontend

    # ----------------------
    # API ROUTES
    # ----------------------

    # Create project
    @app.route("/api/projects", methods=["POST"])
    def create_project():
        data = request.json or {}
        name = data.get("name", "Untitled Project")
        p = Project(name=name)
        db.session.add(p)
        db.session.commit()
        project_folder(p.id)
        return jsonify({
            "success": True,
            "project": {"id": p.id, "name": p.name}
        })

    # List projects
    @app.route("/api/projects", methods=["GET"])
    def list_projects():
        ps = Project.query.order_by(Project.created_at.desc()).all()
        out = [{"id": p.id, "name": p.name} for p in ps]
        return jsonify(out)

    # Upload file to project
    @app.route("/api/projects/<project_id>/upload", methods=["POST"])
    def upload_file(project_id):
        if 'file' not in request.files:
            return jsonify({"error": "file required"}), 400
        f = request.files['file']
        dest = save_upload(project_id, f.filename, f.stream)
        return jsonify({"success": True, "path": dest})

    # Save annotation
    @app.route("/api/projects/<project_id>/annotations", methods=["POST"])
    def save_annotation(project_id):
        payload = request.json
        file_name = payload.get("file_name")
        data = payload.get("data")
        ann = Annotation(project_id=project_id, file_name=file_name, data=data)
        db.session.add(ann)
        db.session.commit()
        p = project_folder(project_id)
        save_json(os.path.join(p, "annotations", f"{ann.id}.json"), data)
        return jsonify({"success": True, "annotation_id": ann.id})

    # List annotations
    @app.route("/api/projects/<project_id>/annotations", methods=["GET"])
    def list_annotations(project_id):
        anns = Annotation.query.filter_by(project_id=project_id).all()
        return jsonify([{"id": a.id, "file_name": a.file_name, "data": a.data} for a in anns])

    # Mistake detection (stub)
    @app.route("/api/projects/<project_id>/detect", methods=["POST"])
    def detect(project_id):
        payload = request.json or {}
        file_name = payload.get("file_name", "")
        results = []
        if "door" in file_name.lower():
            results.append({
                "type": "door_swing_clash",
                "bbox": [100, 100, 200, 200],
                "explanation": "Door swing intersects furniture"
            })
        else:
            results.append({
                "type": "clearance_ok",
                "explanation": "No obvious clearance violations (stub)"
            })
        return jsonify({"success": True, "results": results})


    # Generate report (PDF)
    @app.route("/api/projects/<project_id>/report", methods=["POST"])
    def gen_report(project_id):
        from reportlab.lib.pagesizes import A4
        from reportlab.pdfgen import canvas

        payload = request.json or {}
        p = project_folder(project_id)
        filename = f"report_{uuid.uuid4().hex[:8]}.pdf"
        path = os.path.join(p, "reports", filename)

        c = canvas.Canvas(path, pagesize=A4)
        c.drawString(100, 800, f"Project Report: {project_id}")
        c.drawString(100, 780, f"Notes: {payload.get('notes', 'Generated by system')}")
        c.save()

        r = Report(project_id=project_id, file_path=path)
        db.session.add(r)
        db.session.commit()
        return jsonify({"success": True, "report_id": r.id, "path": path})

    # Download report
    @app.route("/api/projects/<project_id>/report/<report_id>", methods=["GET"])
    def download_report(project_id, report_id):
        r = Report.query.filter_by(id=report_id, project_id=project_id).first_or_404()
        return send_file(r.file_path, as_attachment=True)

    # Discussion endpoint
    @app.route("/api/projects/<project_id>/discuss", methods=["POST"])
    def discuss(project_id):
        payload = request.json or {}
        role = payload.get("role", "user")
        message = payload.get("message", "")

        d = Discussion(project_id=project_id, role=role, message=message)
        db.session.add(d)
        db.session.commit()

        if role == "user":
            ctx = "You are an interior design assistant. Use the project's annotations if available."
            try:
                resp = openai.ChatCompletion.create(
                    model="gpt-4o-mini",
                    messages=[
                        {"role": "system", "content": ctx},
                        {"role": "user", "content": message}
                    ],
                    max_tokens=400
                )
                assistant_text = resp.choices[0].message["content"]
            except Exception as e:
                assistant_text = f"(LLM error: {str(e)})"

            d2 = Discussion(project_id=project_id, role="assistant", message=assistant_text)
            db.session.add(d2)
            db.session.commit()
            return jsonify({"success": True, "assistant": assistant_text})

        return jsonify({"success": True})

    # List discussions
    @app.route("/api/projects/<project_id>/discussions", methods=["GET"])
    def list_discussions(project_id):
        ds = Discussion.query.filter_by(project_id=project_id).order_by(Discussion.created_at).all()
        return jsonify([
            {"id": d.id, "role": d.role, "message": d.message, "created_at": d.created_at.isoformat()}
            for d in ds
        ])

    return app


if __name__ == "__main__":
    app = create_app()
    app.run(debug=True, port=5001)
